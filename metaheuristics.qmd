# Metaheuristics {#sec-metaheuristics}

## Introduction

In the previous chapters, we operated in the realm of mathematical certainty. When the Simplex method terminates, it provides a certificate of optimality. When Branch and Bound finishes a search, we know with absolute confidence that no better integer solution exists. However, not all optimization problems can be solved exactly within a reasonable timeframe. Some problems are NP-hard, meaning that the time required to solve them grows exponentially with the size of the input. In such cases, exact methods become impractical for large instances.

To make progress, we must fundamentally change our goal. We shift from asking *What is the global minimum?* to asking *Can we find a solution that is good enough, quickly enough?*. Nobel laureate Herbert Simon coined the term *satisficing* (a portmanteau of satisfy and suffice) to describe this approach. In CS, this means trading optimality for efficiency. We accept a solution that might be 1% or 5% worse than the theoretical optimum if it allows us to find it in milliseconds rather than millennia.

In this context, we define a **heuristic** as an algorithm that produces a feasible solution to an optimization problem without guaranteeing optimality. Derived from the Greek *heuriskein* ("to find"), a heuristic is a problem-specific strategy designed to find a good solution quickly. Therefore, heuristics rely on domain knowledge and intuition. For instance, in the Traveling Salesman Problem (TSP), a simple heuristic is the nearest neighbor algorithm, which constructs a tour by repeatedly visiting the nearest unvisited city. While this method is fast and often yields a reasonable solution, it does not guarantee the shortest possible tour. It often gets trapped in poor local optima because it never makes a move that looks bad in the short term, even if it is necessary for long-term success.

A **metaheuristic** is a higher-level framework that guides the search process of heuristics, often inspired by natural processes. Metaheuristics are, in general, problem-independent. For instance, the same Genetic Algorithm logic used to design a jet engine nozzle can be used to tune the hyperparameters of a neural network. However, unlike simple heuristics, metaheuristics include mechanisms to escape local optima. They might accept a worse solution temporarily (Simulated Annealing) or maintain a population of diverse solutions (Genetic Algorithms) to avoid getting stuck.

**The Exploration vs. Exploitation Dilemma**

A central theme in metaheuristics is the balance between **exploration** and **exploitation**. Exploration involves searching new areas of the solution space to discover potentially better solutions, while exploitation focuses on refining known good solutions to find local improvements. An effective metaheuristic must strike a balance between these two strategies. Too much exploration can lead to inefficiency, while too much exploitation can cause premature convergence to suboptimal solutions.

A "pure" hill-climber is 100% exploitation. A random search is 100% exploration. The algorithms in this chapter (Simulated Annealing, Tabu Search, and Genetic Algorithms) are successful specifically because they dynamically manage the balance between these two extremes, starting with exploration and gradually shifting toward exploitation.

In the following, we will explore several popular metaheuristic algorithms, discussing their principles, implementations, and applications. We will divide our discussion into **trajectory-based** methods, which iteratively improve a single solution, and **population-based** methods, which evolve a set of solutions over time. In the first case, we will explore Simulated Annealing and Tabu Search as the most prominent examples. In the second case, we will study Genetic Algorithms.

## Trajectory-Based Metaheuristics

The simplest way to explore a landscape is to send out a single hiker. In trajectory-based metaheuristics, we maintain a single candidate solution $x$ and iteratively improve it by exploring its neighbors $x'$. The hiker evaluates nearby points and decides where to move next based on specific criteria. This approach is straightforward and often effective for many optimization problems. The sequence of solutions $x_0, x_1, x_2, \ldots$ generated by the algorithm forms a *trajectory* through the solution space.

The fundamental challenge in this type of methods is to avoid getting stuck in local optima.  A standard "Hill Climber" (or Greedy Descent) algorithm accepts a neighbor only if it is better than the current solution. Consequently, once the hiker reaches a small peak, they get stuck, even if a massive mountain looms just across the valley. To cross that valley, the algorithm must be willing to temporarily accept a worse solution. To address this problem, trajectory-based metaheuristics incorporate strategies to escape local minima and continue exploring the solution space.

We will examine two dominant strategies for doing this: **Simulated Annealing** (which uses randomness) and **Tabu Search** (which uses memory).

### Simulated Annealing

Simulated Annealing (SA) is inspired by the annealing process in metallurgy, where controlled cooling of a material allows atoms to settle into a low-energy configuration. In optimization, SA mimics this process by allowing occasional uphill moves (i.e., accepting worse solutions) to escape local minima. The main idea is to perform the cooling process gradually, starting with a high "temperature" that permits more exploration and slowly lowering it to focus on exploitation.

In SA, our objective function is called "Energy", and the "Temperature" parameter controls the likelihood of accepting worse solutions. At high temperatures, the algorithm is more likely to accept uphill moves, promoting exploration. As the temperature decreases, the algorithm becomes more conservative, favoring downhill moves and refining the current solution.

The algorithm proceeds as follows:

1. Initialize the current solution $x$ and set an initial temperature $T$.
2. Repeat until a stopping criterion is met (e.g., a maximum number of iterations or a minimum temperature):
   - Generate a neighbor solution $x'$ by making a small change to $x$.
   - Calculate the change in energy $\Delta E = E(x') - E(x)$.
   - If $\Delta E < 0$ (i.e., $x'$ is better), accept $x'$ as the new current solution.
   - If $\Delta E \ge 0$, accept $x'$ with a probability of $e^{-\Delta E / T}$.
   - Decrease the temperature $T$ according to a cooling schedule.

The criterion $e^{-\Delta E / T}$ is called the **Metropolis criterion**. It ensures that as the temperature decreases, the probability of accepting worse solutions diminishes, allowing the algorithm to focus on refining the best solutions found. Usually, the cooling schedule is geometric, e.g., $T \leftarrow \alpha T$ with $\alpha \in (0,1)$. A high value of $\alpha$ (e.g., 0.99) results in slow cooling, promoting exploration, while a low value (e.g., 0.8) leads to rapid cooling and quicker convergence.

**Coding Example**

We now implement a solution to the Traveling Salesman Problem (TSP) using Simulated Annealing.

```{python}
import math
import random
import numpy as np

def total_distance(route, dist_matrix):
    """Calculates the total distance of the tour."""
    dist = 0
    for i in range(len(route) - 1):
        dist += dist_matrix[route[i]][route[i+1]]
    dist += dist_matrix[route[-1]][route[0]] # Return to start
    return dist

def simulated_annealing(dist_matrix, initial_temp=1000, cooling_rate=0.995):
    # 1. Initialization
    n_cities = len(dist_matrix)
    current_sol = list(range(n_cities))
    random.shuffle(current_sol)
    current_cost = total_distance(current_sol, dist_matrix)
    
    best_sol = list(current_sol)
    best_cost = current_cost
    
    temp = initial_temp
    
    # 2. The Annealing Loop
    while temp > 1:
        # Create Neighbor: Swap two random cities
        new_sol = list(current_sol)
        i, j = random.sample(range(n_cities), 2)
        new_sol[i], new_sol[j] = new_sol[j], new_sol[i]
        
        new_cost = total_distance(new_sol, dist_matrix)
        
        # Calculate Delta E
        delta_E = new_cost - current_cost
        
        # 3. Acceptance Criteria (Metropolis)
        # If better, accept. If worse, accept with probability exp(-delta/T)
        if delta_E < 0 or random.random() < math.exp(-delta_E / temp):
            current_sol = new_sol
            current_cost = new_cost
            
            # Update Global Best
            if current_cost < best_cost:
                best_sol = list(current_sol)
                best_cost = current_cost
        
        # 4. Cooling
        temp *= cooling_rate
        
    return best_sol, best_cost

# Example Usage
# Create a random distance matrix for 10 cities
dist_matrix = np.random.randint(10, 100, size=(10, 10))
np.fill_diagonal(dist_matrix, 0)

best_route, min_dist = simulated_annealing(dist_matrix)
print(f"Final Best Distance: {min_dist}")
```

The code accepts a distance matrix representing the distances between cities and applies the Simulated Annealing algorithm to find a near-optimal tour. The algorithm starts with a random tour and iteratively improves it by exploring neighboring solutions, accepting worse solutions based on the Metropolis criterion, and gradually cooling down the temperature.

### Tabu Search

While Simulated Annealing relies on rolling dice, Tabu Search (TS) relies on **memory**. It assumes that if we just visited a solution, we shouldn't go back to it immediately. To accomplish this, Tabu Search uses memory structures to guide the search.

The core idea of Tabu Search is to maintain a **tabu list**, which records recently visited solutions or moves. This list prevents the algorithm from revisiting these solutions for a certain number of iterations, thus encouraging exploration of new areas in the solution space. The tabu list can be implemented as a fixed-size queue that stores the last $k$ moves or solutions.

The TS algorithm proceeds as follows:

1. Initialize the current solution $x$ and the tabu list.
2. Repeat until a stopping criterion is met (e.g., a maximum number of iterations):
   - Generate a set of neighbor solutions $N(x)$.
   - Evaluate the neighbors and select the best one $x'$ that is not in the tabu list (or satisfies an aspiration criterion). A neighbor can be accepted even if it's worse than the current solution, as long as it is not tabu.
   - Update the current solution to $x'$. 
   - Update the tabu list by adding the move or solution to it, removing the oldest entry if necessary. It stays there for a specific duration (Tabu Tenure).

**Coding Example**

We will solve a generic problem: finding a binary string of length $n$ that maximizes a value function, using Tabu Search. A "neighbor" is created by flipping exactly one bit.

```{python}
from collections import deque

def objective_function(x):
    # Example: Maximize the number of 1s (OneMax) 
    # In reality, this would be a complex cost function
    return sum(x)

def get_neighbors(solution):
    neighbors = []
    for i in range(len(solution)):
        neighbor = list(solution)
        neighbor[i] = 1 - neighbor[i] # Flip bit i
        neighbors.append((neighbor, i)) # Store solution and the index flipped
    return neighbors

def tabu_search(n_bits, max_iter=100, tabu_tenure=5):
    # 1. Initialization
    current_sol = [random.randint(0, 1) for _ in range(n_bits)]
    best_sol = list(current_sol)
    best_score = objective_function(best_sol)
    
    # Tabu List: Stores indices of bits that were recently flipped
    tabu_list = deque(maxlen=tabu_tenure)
    
    for iteration in range(max_iter):
        neighbors = get_neighbors(current_sol)
        
        # Filter neighbors based on Tabu logic
        best_neighbor = None
        best_neighbor_score = -float('inf')
        move_index = -1
        
        for neighbor, idx in neighbors:
            score = objective_function(neighbor)
            
            is_tabu = idx in tabu_list
            is_aspiration = score > best_score # Aspiration Criteria
            
            # 2. Selection Logic: Allow if NOT Tabu OR meets Aspiration
            if (not is_tabu) or is_aspiration:
                if score > best_neighbor_score:
                    best_neighbor = neighbor
                    best_neighbor_score = score
                    move_index = idx
        
        # 3. Move and Update Memory
        if best_neighbor:
            current_sol = best_neighbor
            tabu_list.append(move_index) # Add the flipped bit to Tabu list
            
            # Update Global Best
            if best_neighbor_score > best_score:
                best_sol = list(best_neighbor)
                best_score = best_neighbor_score
                print(f"Iter {iteration}: New Best Score = {best_score}")
                
    return best_sol, best_score

# Example Usage
final_sol, final_score = tabu_search(n_bits=20, max_iter=50, tabu_tenure=3)
print(f"Final Solution: {final_sol}")
```

The algorithm explores neighboring solutions by flipping bits, while maintaining a tabu list to avoid revisiting recently changed bits. The aspiration criterion allows the algorithm to accept tabu moves if they lead to a new global best solution.

In summary, SA is probabilistic and relies on randomness to escape local optima, while TS is deterministic and uses memory to guide the search. Both methods effectively balance exploration and exploitation, making them powerful tools for solving complex optimization problems. In the next section, we will explore population-based metaheuristics, which maintain a diverse set of solutions to explore the solution space more broadly.

## Population-Based Metaheuristics

In trajectory-based methods (SA, TS), we send a single agent moving through the solution space. While effective, this approach has a limitation: the agent is lonely. It cannot learn from the successes or failures of other agents. Population-based metaheuristics address this limitation by maintaining a **population** of candidate solutions. Multiple agents explore the solution space simultaneously, sharing information and learning from each other. For instance, if Solution A has a good parameter for the first half of the problem, and Solution B has a good parameter for the second half, population methods attempt to combine them to create a superior Solution C. This collective behavior often leads to more robust exploration and better overall solutions. The most famous family of these algorithms is **Evolutionary Computation**, of which **Genetic Algorithms** (GAs) are the most well-known example.

### Genetic Algorithms

Genetic Algorithms (GAs) are inspired by the principles of natural selection and genetics. They simulate the process of evolution by maintaining a population of candidate solutions (individuals) that evolve over generations. Each individual is typically represented as a chromosome, often encoded as a binary string, but other representations are also possible.

In any GA, we find the following key components:

- **Individuals:** Candidate solutions (e.g. a vector of weights). This would correspond to the *phenotype* in biology.
- **Chromosomes:** The genetic representation of individuals (e.g. binary strings). This corresponds to the *genotype* of the individual.
- **Gene:** A single unit of information in a chromosome (e.g. a bit in a binary string).
- **Fitness Function:** A function that evaluates how good an individual is with respect to the optimization objective.
- **Generation:** A single iteration of the algorithm, where the population is updated.

The GA algorithm proceeds in a loop where four biological-inspired operations are performed:

1. **Selection:** Individuals are selected from the current population to serve as parents for the next generation. Selection is typically based on fitness, with fitter individuals having a higher probability of being chosen. 
2. **Crossover (Recombination):** Pairs of parents are combined to produce offspring. This is done by exchanging segments of their chromosomes, simulating genetic recombination.
3. **Mutation:** Random changes are introduced to the offspring's chromosomes to maintain genetic diversity and explore new areas of the solution space. 
4. **Replacement:** The new generation of individuals replaces the old population, often keeping some of the best individuals (elitism) to ensure that good solutions are not lost.

In the following, we will dive deeper into each of these components and provide a coding example of a Genetic Algorithm applied to a simple optimization problem.

**Selection Methods**

Several selection methods exist, each with its own advantages and disadvantages: 

- **Roulette Wheel Selection:** Individuals are selected with a probability proportional to their fitness. This method can be biased towards very fit individuals, potentially reducing diversity.
- **Tournament Selection:** A subset of individuals is randomly chosen, and the fittest among them is selected as a parent. This method maintains diversity while still favoring fitter individuals.
- **Rank Selection:** Individuals are ranked based on fitness, and selection probabilities are assigned based on rank rather than absolute fitness. This helps to prevent premature convergence.

The following example shows an implementation of tournament selection.

```{python}
import numpy as np

def select_parents(population, fitnesses):
    """Tournament Selection: Pick 3, return the best."""
    parents = []
    for _ in range(len(population)):
        # Randomly sample 3 indices
        indices = np.random.randint(0, len(population), 3)
        # Find the one with the highest fitness
        best_idx = indices[np.argmax(fitnesses[indices])]
        parents.append(population[best_idx])
    return np.array(parents)
```

**Crossover Methods**

Crossover methods vary in how they combine the genetic material of the parents. Common methods include:

- **One-point Crossover:** A single crossover point is selected, and the offspring are created by exchanging the segments after this point.
- **Two-point Crossover:** Two crossover points are selected, and the segments between these points are exchanged.
- **Uniform Crossover:** Each gene is independently swapped with a certain probability.

The following example demonstrates one-point crossover.

```{python}
def crossover(parent1, parent2):
    """Single-Point Crossover."""
    if np.random.rand() < 0.8: # 80% chance to mate
        point = np.random.randint(1, len(parent1))
        child1 = np.concatenate((parent1[:point], parent2[point:]))
        child2 = np.concatenate((parent2[:point], parent1[point:]))
        return child1, child2
    return parent1.copy(), parent2.copy()
```

**Mutation Methods**

Mutation introduces random changes to the offspring's chromosomes to maintain diversity. Common mutation methods include:
- **Bit Flip Mutation:** For binary strings, randomly flip bits with a certain probability.
- **Gaussian Mutation:** For real-valued representations, add a small random value drawn from a Gaussian distribution to the genes.

The following example shows bit flip mutation.

```{python}
def mutate(individual):
    """Gaussian Mutation: Add small noise."""
    for i in range(len(individual)):
        if np.random.rand() < MUTATION_RATE:
            # Add random noise
            individual[i] += np.random.normal(0, 0.5)
    return individual
```

**Putting It All Together**

Now we can implement a simple Genetic Algorithm that combines these components to optimize a function. For demonstration purposes, we will implement a GA to minimize the Sphere Function defined as $f(x) = \sum_{i=1}^{n} x_i^2$, which has a global minimum at $x = 0$. While GAs were originally designed for binary strings, they are heavily used today for continuous optimization (e.g., tuning hyperparameters).

```{python}
import numpy as np

# --- Configuration ---
POP_SIZE = 50        # Number of individuals
GENES = 10           # Number of variables (dimensions)
GENERATIONS = 100    # How long to run
MUTATION_RATE = 0.1  # Probability of mutation per gene
ELITISM_COUNT = 2    # Number of top solutions to keep

def fitness_function(individual):
    """Objective: Minimize sum of squares (Sphere function)."""
    # We negate because GAs typically maximize fitness
    return -np.sum(individual**2)

def create_population(size, n_genes):
    """Initialize random real-valued population between -5.12 and 5.12"""
    return np.random.uniform(-5.12, 5.12, (size, n_genes))

# --- Main GA Loop ---
population = create_population(POP_SIZE, GENES)

for gen in range(GENERATIONS):
    # 1. Evaluate Fitness
    fitnesses = np.array([fitness_function(ind) for ind in population])
    
    # Track stats
    best_idx = np.argmax(fitnesses)
    if gen % 10 == 0:
        print(f"Gen {gen}: Best Fitness = {fitnesses[best_idx]:.5f}")
        
    # 2. Elitism: Keep the best
    # Sort indices by fitness (descending)
    sorted_indices = np.argsort(fitnesses)[::-1]
    elites = population[sorted_indices[:ELITISM_COUNT]]
    
    # 3. Selection
    parents = select_parents(population, fitnesses)
    
    # 4. Crossover & Mutation
    next_population = []
    # Add elites first
    next_population.extend(elites)
    
    # Fill the rest
    for i in range(0, POP_SIZE - ELITISM_COUNT, 2):
        p1, p2 = parents[i], parents[i+1]
        c1, c2 = crossover(p1, p2)
        next_population.append(mutate(c1))
        if len(next_population) < POP_SIZE:
            next_population.append(mutate(c2))
            
    population = np.array(next_population)

# Final Result
final_fitnesses = np.array([fitness_function(ind) for ind in population])
best_sol = population[np.argmax(final_fitnesses)]
print(f"Final Solution: {best_sol}")
```

In this implementation, we initialize a population of random solutions and iteratively apply selection, crossover, and mutation to evolve the population towards better solutions. We also use elitism to ensure that the best solutions are preserved across generations. The algorithm optimizes the Sphere function, and we track the best fitness at regular intervals.

The power of GA lies in its ability to explore a large and complex solution space effectively, making it suitable for a wide range of optimization problems, from engineering design to machine learning hyperparameter tuning. In general, GAs are easily parallelizable, as the evaluation of fitness for different individuals can be done independently, making them well-suited for modern computational architectures. Additionally, they do not require gradients, making them applicable to non-differentiable or noisy optimization problems. Finally, the combination of crossover and mutation allows GAs to maintain diversity in the population, helping to avoid premature convergence to local optima.

## Theoretical Considerations

We have now explored different metaheuristic algorithms, each with its own strengths and weaknesses. While these methods are powerful, it is important to understand their theoretical underpinnings and limitations. If we are building a routing system for a logistics company, should we default to a Genetic Algorithm because it sounds the most sophisticated? Or stick to Simulated Annealing because it is easier to code?

### The No Free Lunch Theorems

While answering this question is complex, part of the answer lies in the **No Free Lunch Theorems** for optimization. These theorems state that no optimization algorithm is universally superior to others when averaged over all possible problems. In other words, an algorithm that performs well on one class of problems may perform poorly on another. Therefore, the choice of metaheuristic should be informed by the specific characteristics of the problem at hand.

We can derive the following implications from the No Free Lunch Theorems:

- There is no "super algorithm" that is best for all optimization problems. The effectiveness of an algorithm depends on the structure of the problem.
- Performance comes from specialization: An algorithm that is tailored to exploit the specific features of a problem will outperform a general-purpose algorithm on that problem.
- Domain knowledge is crucial: Understanding the problem domain can guide the design of heuristics and metaheuristics that are more effective for that particular problem.

Specifically, the job of the computer scientist is not just to pick an algorithm from a library, but to understand the *geometry* of their specific problem. For instance, if the problem has a "smooth" landscape, we can use a trajectory method like SA. However, if it has a "modular" structure instead (where combining parts of solution A and B makes sense), probably using a Genetic Algorithm would be the best choice.

### Hyperparameters and Tuning

The second theoretical hurdle is the issue of configuration. Exact algorithms like Simplex have very few parameters. Metaheuristics, however, are full of "knobs" that must be tuned. For instance, in SA we have the initial temperature, cooling rate, and stopping criteria. In GAs, we have population size, mutation rate, crossover rate, selection method, and more. The performance of these algorithms can be highly sensitive to the choice of these hyperparameters.

So how do we choose e.g. the correct mutation rate? Ideally, we want the mutation rate that minimizes our loss function. But finding that rate is itself an optimization problem. We are effectively trying to "optimize the optimizer". This meta-optimization can be computationally expensive and may require specialized techniques.

For instance, one of the most common methods for hyperparameter tuning is **Grid Search**, where we define a discrete set of values for each hyperparameter and evaluate the performance of the algorithm for every combination. While this method is straightforward, it can be computationally expensive, especially when the number of hyperparameters and their possible values increases.

Additionally, there are more sophisticated methods like **Random Search**, which samples hyperparameter combinations randomly, and **Bayesian Optimization**, which builds a probabilistic model of the objective function and uses it to select promising hyperparameter values. These methods can be more efficient than Grid Search, especially in high-dimensional hyperparameter spaces.

## Summary

In this chapter, we explored the world of metaheuristics, which are powerful tools for solving complex optimization problems that are intractable for exact methods. We discussed the fundamental concepts of heuristics and metaheuristics, and how they differ from traditional optimization algorithms. We delved into trajectory-based methods like Simulated Annealing and Tabu Search, which use randomness and memory to escape local optima. We also examined population-based methods like Genetic Algorithms, which maintain a diverse set of solutions to explore the solution space more effectively.

Finally, we discussed theoretical considerations such as the No Free Lunch Theorems, which highlight the importance of problem-specific algorithm design, and the challenges of hyperparameter tuning in metaheuristics. Understanding these concepts is crucial for effectively applying metaheuristic algorithms to real-world optimization problems.

## Exercises

1. Implement a Simulated Annealing algorithm to solve the Knapsack Problem. Compare its performance with a simple greedy heuristic.

2. Implement a Tabu Search algorithm for the Job Scheduling Problem. In the Job Scheduling Problem, we have a set of jobs, each with a processing time and a deadline. The goal is to schedule the jobs in a way that minimizes the total tardiness (the amount of time by which jobs miss their deadlines). Experiment with different tabu tenures and aspiration criteria to see how they affect the performance of the algorithm.

3. Implement a Genetic Algorithm to optimize the Rastrigin function, which is a non-convex function used as a performance test problem for optimization algorithms. The Rastrigin function is defined as:
   $$
   f(x) = 10n + \sum_{i=1}^{n} [x_i^2 - 10\cos(2\pi x_i)]
   $$

   where $n$ is the number of dimensions and $x_i$ are the input variables. Experiment with different selection methods, crossover rates, and mutation rates to find the best configuration for optimizing this function.

4. Explore the No Free Lunch Theorems by implementing a simple optimization problem (e.g., maximizing a function) and comparing the performance of different metaheuristic algorithms (e.g., Simulated Annealing, Tabu Search, Genetic Algorithm) on this problem. Analyze how the structure of the problem affects the performance of each algorithm.

