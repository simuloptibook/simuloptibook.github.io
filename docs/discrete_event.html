<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>4&nbsp; Discrete events and Queuing Theory – Simulation and Optimization: A Model-Driven Approach</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./optimization_basics.html" rel="next">
<link href="./monte_carlo.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-e48e5d47e6899f26dc5bcf87b02f963a.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./simulation_basics.html">PART I: SIMULATION</a></li><li class="breadcrumb-item"><a href="./discrete_event.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Discrete events and Queuing Theory</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Simulation and Optimization: A Model-Driven Approach</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">PART I: SIMULATION</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./simulation_basics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Simulation basics</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./monte_carlo.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Monte Carlo</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./discrete_event.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Discrete events and Queuing Theory</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">PART II: OPTIMIZATION</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./optimization_basics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Optimization basics</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./exact_methods.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Exact methods</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./metaheuristics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Metaheuristics</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./optimization_in_ml.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Optimization and Simulation in Machine Learning</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./summary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Summary</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">4.1</span> Introduction</a></li>
  <li><a href="#sec-queuing-theory" id="toc-sec-queuing-theory" class="nav-link" data-scroll-target="#sec-queuing-theory"><span class="header-section-number">4.2</span> Queuing Theory</a>
  <ul class="collapse">
  <li><a href="#anatomy-of-a-queuing-system" id="toc-anatomy-of-a-queuing-system" class="nav-link" data-scroll-target="#anatomy-of-a-queuing-system"><span class="header-section-number">4.2.1</span> Anatomy of a Queuing System</a></li>
  <li><a href="#kendalls-notation" id="toc-kendalls-notation" class="nav-link" data-scroll-target="#kendalls-notation"><span class="header-section-number">4.2.2</span> Kendall’s Notation</a></li>
  <li><a href="#key-performance-measures" id="toc-key-performance-measures" class="nav-link" data-scroll-target="#key-performance-measures"><span class="header-section-number">4.2.3</span> Key Performance Measures</a></li>
  <li><a href="#example-the-mm1-queue" id="toc-example-the-mm1-queue" class="nav-link" data-scroll-target="#example-the-mm1-queue"><span class="header-section-number">4.2.4</span> Example: The M/M/1 Queue</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary"><span class="header-section-number">4.2.5</span> Summary</a></li>
  </ul></li>
  <li><a href="#discrete-event-simulation" id="toc-discrete-event-simulation" class="nav-link" data-scroll-target="#discrete-event-simulation"><span class="header-section-number">4.3</span> Discrete Event Simulation</a>
  <ul class="collapse">
  <li><a href="#components-of-a-des-model" id="toc-components-of-a-des-model" class="nav-link" data-scroll-target="#components-of-a-des-model"><span class="header-section-number">4.3.1</span> Components of a DES Model</a></li>
  <li><a href="#the-des-worldview" id="toc-the-des-worldview" class="nav-link" data-scroll-target="#the-des-worldview"><span class="header-section-number">4.3.2</span> The DES Worldview</a></li>
  <li><a href="#building-a-simulation-study" id="toc-building-a-simulation-study" class="nav-link" data-scroll-target="#building-a-simulation-study"><span class="header-section-number">4.3.3</span> Building a Simulation Study</a></li>
  <li><a href="#analyzing-the-output" id="toc-analyzing-the-output" class="nav-link" data-scroll-target="#analyzing-the-output"><span class="header-section-number">4.3.4</span> Analyzing the Output</a></li>
  </ul></li>
  <li><a href="#comparative-study" id="toc-comparative-study" class="nav-link" data-scroll-target="#comparative-study"><span class="header-section-number">4.4</span> Comparative Study</a></li>
  <li><a href="#summary-1" id="toc-summary-1" class="nav-link" data-scroll-target="#summary-1"><span class="header-section-number">4.5</span> Summary</a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="header-section-number">4.6</span> Exercises</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./simulation_basics.html">PART I: SIMULATION</a></li><li class="breadcrumb-item"><a href="./discrete_event.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Discrete events and Queuing Theory</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-discrete-events" class="quarto-section-identifier"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Discrete events and Queuing Theory</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">4.1</span> Introduction</h2>
<p>In the previous chapters, we have considered mostly continuous simulation approaches. These approaches are well suited for situations where systems can be described using simple equations. However, there are situations that are either too complex to be modeled in such a way, or too expensive or dangerous to experiment with in the real world. Whether it is a hospital emergency room attempting to reduce patient wait times, a manufacturing plant trying to optimize throughput, or a computer network managing data packets, these systems share a common trait: they change state at specific, irregular points in time.</p>
<p>Unlike other modeling approaches that view the world as a continuous flow or a static snapshot, <strong>Discrete Event Simulation (DES)</strong> views the world as a sequence of distinct events—arrivals, departures, breakdowns, and completions—that occur at specific instants, triggering changes in the system’s state. DES becomes necessary when a system exhibits the following properties:</p>
<ul>
<li>The state of the system <strong>evolves over time</strong>. A decision made at time <span class="math inline">\(t\)</span> affects the resources available at time <span class="math inline">\(t+1\)</span>.</li>
<li>Entities (like customers, parts, data) compete for <strong>limited resources</strong> (counters, machines, bandwidth) leading to the formation of <em>queues</em>.</li>
<li>The system is driven by <strong>randomness</strong>. Customers do not arrive at fixed intervals; machines do not take the exact same amount of time to process every part.</li>
</ul>
<p>We utilize DES when analytical solutions are mathematically intractable. For example, calculating the average wait time in a bank with one line and one teller is a simple mathematical exercise. However, if that bank has varying arrival rates depending on the time of day, tellers who take lunch breaks, and customers who may leave (balk) if the line is too long, the mathematical formulas break down. DES allows us to mimic this complex reality inside a computer to answer “What if?” questions without disrupting actual operations.</p>
<p>Note that Monte Carlo simulation can be considered in general as <strong>static</strong>. It evaluates a problem at a single point in time or across a timeless dimension. For instance, estimating the value of <span class="math inline">\(\pi\)</span> by dropping distinct pins on a grid is a Monte Carlo experiment. It provides a probabilistic outcome of a specific scenario but does not model how that scenario evolves. By contrast, DES is <strong>dynamic</strong>, creating a history of the system operation over a duration.</p>
<p>The mathematical foundation that represents the basis for DES is called <strong>Queuing Theory</strong>. It underpins the computational engine used by DES to solve complex simulation problems. Queuing Theory provides the analytical framework for understanding waiting lines. It offers exact mathematical formulas to predict performance measures such as server utilization or and average waiting times under specific, idealized assumptions (e.g., purely random arrivals and service times).</p>
<p>In this chapter, we will introduce the fundamentals of Queuing Theory that will serve as a framework to understand the principles of DES. While Queuing Theory provides the “laws of physics” for the system at hand, DES provides the laboratory in which we experiment with those laws under complex, realistic conditions.</p>
</section>
<section id="sec-queuing-theory" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="sec-queuing-theory"><span class="header-section-number">4.2</span> Queuing Theory</h2>
<p>Before we can build a valid discrete simulation model, we must understand the mathematical logic that governs the flow of entities. Queuing Theory is the study of waiting lines. It provides a set of analytical techniques used to describe the behavior of systems where entities arrive, wait for a resource, receive service, and depart. While we often associate queues with negative experiences—standing in line at a grocery store or waiting on hold for customer support—queuing theory views the queue not as a nuisance, but as a buffer. It is a necessary component that manages the mismatch between the irregular demand for service and the limited capacity to provide it. The fundamental goal of queuing theory is to quantify the trade-off between the cost of providing service (adding more servers) and the cost of waiting (lost time or unhappy customers).</p>
<section id="anatomy-of-a-queuing-system" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1" class="anchored" data-anchor-id="anatomy-of-a-queuing-system"><span class="header-section-number">4.2.1</span> Anatomy of a Queuing System</h3>
<p>We now decompose a queueing system into its basic constituent processes: the arrival, the queue and the service mechanism.</p>
<ul>
<li>The <strong>arrival process</strong> defines how entities appear. In most queuing models, we assume that arrivals are random and measure them using the <em>interarrival time</em>, which is the time elapsed between two consecutive arrivals.</li>
<li>The <strong>queuing mechanism</strong> defines how the holding area looks like where entities wait for service. This queue might have finite or infinite capacity, and function according to a specific principle or set of rules. The most common is a First-In, First-Out (FIFO) mechanism, where the first entity that arrived at the queue will get service first, and all other entities will advance by one place on the waiting line. However, other (less frequent) mechanisms might be used like LIFO (Last-In, Fist-Out), SIRO (Service In Random Order) or some other Priority schemes.</li>
<li>The <strong>service mechanism</strong> defines how entities are processed, e.g.&nbsp;in a serial way (only one server) or with several concurrent servers. Additionally, this mechanism is characterized by a <em>service time</em>, which is usually stochastic as well.</li>
</ul>
<p><strong>Revisiting the Supermarket</strong></p>
<p>Coming back to the supermarket example of <a href="intro.html" class="quarto-xref"><span>Chapter 1</span></a>, we can now identify the system’s components as follows:</p>
<ul>
<li><strong>Arrival:</strong> Customers arrive randomly following exponentially distributed interarrival times.</li>
<li><strong>Queueing mechanism:</strong> Customers are put into an infinite waiting room (the queue has infinite capacity) and they are served sequentially, using a FIFO mechanism.</li>
<li><strong>Service:</strong> Once that the customers arrive at checkout, they are serviced by the next available of <span class="math inline">\(c\)</span> cashiers. Service times are exponentially distributed.</li>
</ul>
<p>In general, Queuing Theory provides a mathematical framework for ideal systems which can be handled analytically. However, this is not always the case. For these cases, DES offers a mechanistic approach to perform realistic system simulations. Nevertheless, Queuing Theory can also be used in this cases to provide a calibration benchmark or a “sanity check” for a simulation study by simplifying the model and checking that the results of the DES are the same than the ones predicted by the theory.</p>
</section>
<section id="kendalls-notation" class="level3" data-number="4.2.2">
<h3 data-number="4.2.2" class="anchored" data-anchor-id="kendalls-notation"><span class="header-section-number">4.2.2</span> Kendall’s Notation</h3>
<p>Queuing systems can vary in some specific ways: for instance, different arrival patterns, number of servers, etc. In order to describe these different modalities, we will use a formal notation called <strong>Kendall’s Notation</strong>. This notation is based on three components in the format <strong><span class="math inline">\(A/B/c\)</span></strong>. Each of these components represent the following characteristics:</p>
<ul>
<li><strong><span class="math inline">\(A\)</span>:</strong> Denotes the probability distribution of the <em>arrival</em> times.</li>
<li><strong><span class="math inline">\(B\)</span>:</strong> Denotes the probability distribution of the <em>service</em> times.</li>
<li><strong><span class="math inline">\(c\)</span>:</strong> Denotes the number of parallel channels available (e.g.&nbsp;number of servers).</li>
</ul>
<p>Some symbols for common distributions used in practice for <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> include:</p>
<ul>
<li><strong><span class="math inline">\(M\)</span>:</strong> The <em>memoryless</em> (or Markovian) distribution. This implies for times the use of the exponential distribution, and for counts the Poisson distribution.</li>
<li><strong><span class="math inline">\(D\)</span>:</strong> Denotes a deterministic mechanism where times are constant (zero variance). For instance, the service time in an automated car wash could take always the same 5 minutes per car.</li>
<li><strong><span class="math inline">\(G\)</span>:</strong> Denotes any general distribution like Gaussian, Gamma, etc.</li>
</ul>
<p>Some examples include the <span class="math inline">\(M/M/1\)</span> model (exponential arrivals, exponential service times, and 1 server), <span class="math inline">\(M/M/c\)</span> (same as before but with <span class="math inline">\(c\)</span> servers in parallel) and <span class="math inline">\(M/D/1\)</span> (exponential arrivals, fixed service times, and 1 server).</p>
</section>
<section id="key-performance-measures" class="level3" data-number="4.2.3">
<h3 data-number="4.2.3" class="anchored" data-anchor-id="key-performance-measures"><span class="header-section-number">4.2.3</span> Key Performance Measures</h3>
<p>We now describe some measures used to quantify how well the system performs. These metrics measure, in general, two competing objectives: the efficiency of the resource and the waiting time of the customer.</p>
<p>Let our input parameters be <span class="math inline">\(\lambda\)</span> (the mean arrival rate, e.g.&nbsp;10 customers per hour) and <span class="math inline">\(\mu\)</span> (the mean service rate per server, e.g.&nbsp;a bank teller handling on average 15 customers per hour). In the following, we will use the term <em>queue</em> to refer to the waiting line itself, whereas <em>queueing system</em> refers to the whole system (the queue plus the service).</p>
<p><strong>Utilization factor</strong></p>
<p>We denote the fraction of time each server is busy, or utilization factor by <span class="math inline">\(\rho\)</span>. It measures how efficiently the servers are being used:</p>
<p><span class="math display">\[
\rho=\frac{\lambda}{c\mu}
\]</span></p>
<p>Note that if the arrival rate exceeds the service rate, the queue size diverges to infinity (i.e.&nbsp;the condition <span class="math inline">\(\rho &lt; 1\)</span> is a sufficient condition for stability).</p>
<p><strong>State metrics</strong></p>
<p>We now assume that the system is in a steady state, i.e.&nbsp;the system has been running for long enough so that the initial conditions no longer influence current state probabilities. The state of the system is modeled as a random variable. Let <span class="math inline">\(P_n\)</span> denote the steady state probability that there are exactly <span class="math inline">\(n\)</span> entities in the system. We seek to minimize the following state metrics for any queuing system:</p>
<ul>
<li><span class="math inline">\(L\)</span>: The length of the system, or average total number of waiting entities and those being served. This is the expected value of the number of entities:</li>
</ul>
<p><span class="math display">\[
L=\sum_{n=0}^\infty n\cdot P_n
\]</span></p>
<ul>
<li><span class="math inline">\(L_q\)</span>: The length of the queue, or average number of entities in the waiting line. We define this quantity as the expected value of entities waiting in the line, excluding the ones being served:</li>
</ul>
<p><span class="math display">\[
L_q = \sum_{n=c+1}^\infty (n-c)\cdot P_n
\]</span></p>
<ul>
<li><span class="math inline">\(W\)</span>: The total time in the system, or the average time an entity spends in the system (waiting + served). This is the sum of the expected time waiting in the queue plus the expected service time.</li>
</ul>
<p><span class="math display">\[
W=E[\text{Waiting Time}]+E[\text{Service Time}]
\]</span></p>
<ul>
<li><span class="math inline">\(W_q\)</span>: The waiting time in queue, or average time an entity spends in the waiting line before being served. This can be expressed by:</li>
</ul>
<p><span class="math display">\[
W_q = W - \frac{1}{\mu}
\]</span></p>
<p>or the time waiting until one of the servers becomes free.</p>
<p><strong>Little’s Law</strong></p>
<p>One of the best known results in queuing theory is known as <strong>Little’s law</strong>, which established a fundamental relationship between the number of items in the system <span class="math inline">\(L\)</span>, the arrival rate <span class="math inline">\(\lambda\)</span> and the average time spent in the system <span class="math inline">\(W\)</span>:</p>
<p><span id="eq-littles-law"><span class="math display">\[
L=\lambda\times W
\tag{4.1}\]</span></span></p>
<p>This relation holds true regardless of the probability distributions involved. <a href="#fig-littles-law" class="quarto-xref">Figure&nbsp;<span>4.1</span></a> shows a geometric visualization of Little’s Law.</p>
<div id="fig-littles-law" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-littles-law-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/chapter_4/littles_law_illustration.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-littles-law-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.1: Geometric Visualization of Little’s Law
</figcaption>
</figure>
</div>
<p>In this plot, we represent a realization of a <span class="math inline">\(M/M/1\)</span> process where the cumulative arrivals are denoted by <span class="math inline">\(A(t)\)</span> and the cumulative departures by <span class="math inline">\(D(t)\)</span>. From the horizontal perspective (the customer’s view), each horizontal section represents the arrival and departure of an entity (e.g.&nbsp;in the plot the green line represents the total time <span class="math inline">\(W_5\)</span> that Entity 5 spent in the system). If we sum for all <span class="math inline">\(N\)</span> customers, and we denote by <span class="math inline">\(W\)</span> the average total time per customer, we get an estimation of the total system time (the grey area) of <span class="math inline">\(\approx N\times W\)</span>.</p>
<p>From the vertical perspective, each vertical section represents a moment in time, with its length equal to the number of entities in the system. If we now sum for all times, we also get an estimation of the total system time of <span class="math inline">\(\approx T \times L\)</span>, where <span class="math inline">\(T\)</span> is the duration of the simulation and <span class="math inline">\(L\)</span> is the average number of entities in the system. Equating both, we get:</p>
<p><span class="math display">\[
N\times W = T\times L
\]</span></p>
<p>and therefore</p>
<p><span class="math display">\[
L = \frac{N}{T}\times W
\]</span></p>
<p>where <span class="math inline">\(N/T\)</span> is exactly the arrival rate <span class="math inline">\(\lambda\)</span>, and we thus get <a href="#eq-littles-law" class="quarto-xref">Equation&nbsp;<span>4.1</span></a>.</p>
</section>
<section id="example-the-mm1-queue" class="level3" data-number="4.2.4">
<h3 data-number="4.2.4" class="anchored" data-anchor-id="example-the-mm1-queue"><span class="header-section-number">4.2.4</span> Example: The M/M/1 Queue</h3>
<p>As an example, we now calculate <span class="math inline">\(L\)</span>, <span class="math inline">\(L_q\)</span>, <span class="math inline">\(W\)</span> and <span class="math inline">\(W_q\)</span> explicitly for the case of an <span class="math inline">\(M/M/1\)</span> queue. For the arrivals, we assume a Poisson process with rate <span class="math inline">\(\lambda\)</span>, exponential service times with rate <span class="math inline">\(\mu\)</span> and 1 server. This results in an utilization of <span class="math inline">\(\rho=\lambda/\mu\)</span> and we assume <span class="math inline">\(\rho&lt;1\)</span> so that the queue remains stable.</p>
<p>The steady state probability <span class="math inline">\(P_n\)</span> becomes then</p>
<p><span class="math display">\[
P_n=(1-\rho)\rho^n
\]</span></p>
<p>where <span class="math inline">\((1-\rho)\)</span> is the probability that the system is empty. The length of the system <span class="math inline">\(L\)</span> becomes then:</p>
<p><span class="math display">\[
L=\sum_{n=0}^\infty n\cdot P_n = \sum_{n=0}^\infty n\cdot (1-\rho)\rho^n=(1-\rho)\sum_{n=0}^\infty n \rho^n
\]</span></p>
<p>because this is a geometric summation, we get</p>
<p><span class="math display">\[
L=(1-\rho)\frac{\rho}{(1-\rho)^2}=\frac{\rho}{(1-\rho)}=\frac{\lambda}{\mu-\lambda}
\]</span></p>
<p>Using Little’s Law, we can now easily find <span class="math inline">\(W\)</span>:</p>
<p><span class="math display">\[
W=\frac{L}{\lambda}=\frac{1}{\mu-\lambda}
\]</span></p>
<p>Similarly, the total time in the queue <span class="math inline">\(W_q\)</span> can be calculated as follows:</p>
<p><span class="math display">\[
W_q = W-\frac{1}{\mu}=\frac{1}{\mu-\lambda}-\frac{1}{\mu}=\frac{\lambda}{\mu(\mu-\lambda)}
\]</span></p>
<p>Applying Little’s Law for the queue (<span class="math inline">\(L_q=\lambda W_q\)</span>), we get:</p>
<p><span class="math display">\[
L_q=\frac{\lambda^2}{\mu(\mu-\lambda)}
\]</span></p>
</section>
<section id="summary" class="level3" data-number="4.2.5">
<h3 data-number="4.2.5" class="anchored" data-anchor-id="summary"><span class="header-section-number">4.2.5</span> Summary</h3>
<p>We have now seen the basic definitions behind Queuing Theory and the main performance measures that we seek to optimize. Depending on the actual form of the system (<span class="math inline">\(M/M/1\)</span>, <span class="math inline">\(M/M/c\)</span>, etc.) each measure takes a specific analytical form that can be calculated explicitly. However, with increasing complexity it becomes more difficult to get exact analytical expressions for these quantities. For these scenarios, we use DES as a simulation tool as we will explore in the next sections.</p>
</section>
</section>
<section id="discrete-event-simulation" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="discrete-event-simulation"><span class="header-section-number">4.3</span> Discrete Event Simulation</h2>
<p>While Queuing Theory provides the laws of physics for waiting lines, it has a significant limitation: it requires the world to be well-behaved. The moment we introduce real-world messiness—dynamic arrival rates (e.g., the lunch rush), complex routing logic (e.g., a part returning to a machine for rework), or resource dependencies (e.g., a machine needs both an operator and a tool)—the analytical formulas of Queuing Theory become mathematically unsolvable.</p>
<p>When the assumptions of Queuing Theory aren’t valid anymore, we turn to <strong>Discrete Event Simulation (DES)</strong>. Discrete Event Simulation is a computational technique used to model the operation of a system as a discrete sequence of events in time. The defining characteristic of DES is how it handles state changes. In a continuous system (like water flowing into a tank), the state changes continuously every millisecond. In a discrete system, the state is piecewise constant. The number of people in a line remains exactly the same for a period of time, then changes instantaneously when a person arrives or departs. Therefore, a DES model assumes that nothing interesting happens between events. This assumption allows the computer to skip over periods of inactivity, making the simulation highly efficient.</p>
<section id="components-of-a-des-model" class="level3" data-number="4.3.1">
<h3 data-number="4.3.1" class="anchored" data-anchor-id="components-of-a-des-model"><span class="header-section-number">4.3.1</span> Components of a DES Model</h3>
<p>In order to define a DES model, we need to map the physical elements of the system to simulation components.</p>
<ol type="1">
<li><p><strong>Entities:</strong> The dynamic objects that flow through the system (e.g.&nbsp;customers of a bank, data packets in a computer network, etc.). Entities arrive, move through the system, queue for resources, and leave the system (depart).</p></li>
<li><p><strong>Attributes:</strong> Local data tags that describe the unique characteristics of a specific entity (e.g.&nbsp;the arrival time of an entity, the severity of a patient, etc). With attributes, we can treat in the simulation different entitites differently.</p></li>
<li><p><strong>Resources:</strong> Stationary elements that provide service to entities and have limited capacity (e.g.&nbsp;tellers, machines, doctos, etc). Resources have normally at least two states: idle (free) and busy (occupied).</p></li>
<li><p><strong>Global variables:</strong> Data tags that belong to the whole system instead of individual entities. They normally track the aggregated state of the system (e.g.&nbsp;the current length of the queue, number of busy servers, etc).</p></li>
<li><p><strong>Events:</strong> An instantaneous occurrence that changes the state of the system. Events like arrivals and departures are considered as primary events, whereas other types of events (breakdowns, shift changes, etc) are considered as secondary events.</p></li>
</ol>
</section>
<section id="the-des-worldview" class="level3" data-number="4.3.2">
<h3 data-number="4.3.2" class="anchored" data-anchor-id="the-des-worldview"><span class="header-section-number">4.3.2</span> The DES Worldview</h3>
<p>In a DES simulation, time is not considered to flow like a clock does. Between events, nothing interesting (from the point of view of the simulation) happens, so the next “tick” of the clock actually happens with the next event. In order to be able to manage these discrete jumps, it is usual for DES to maintain a <strong>Future Event List (FEL)</strong>. Intuitively, this is a sort of “To-Do List” where all known future events are sorted chronologically.</p>
<p>The general simulation loop then becomes as follows:</p>
<ol type="1">
<li>Check the FEL to find the event with the smalles time stamp.</li>
<li>Advance the simulation clock to that time.</li>
<li>Execute the logic associated with that event (e.g., free the server, update statistics, etc).</li>
<li>Generate possible new events and place them into the FEL.</li>
<li>Repeat until simulation end is reached.</li>
</ol>
</section>
<section id="building-a-simulation-study" class="level3" data-number="4.3.3">
<h3 data-number="4.3.3" class="anchored" data-anchor-id="building-a-simulation-study"><span class="header-section-number">4.3.3</span> Building a Simulation Study</h3>
<p>A widely held misconception about DES is that “simulation” is synonymous with “coding.” In reality, writing the code is often the shortest phase of a project. A simulation study is a structured systems engineering process. If the conceptualization is flawed or the data is inaccurate, the most sophisticated code in the world will yield useless results.</p>
<p>To ensure reliability, a simulation study generally follows a standard five-step life cycle.</p>
<ol type="1">
<li><p><strong>Problem formulation:</strong> Before we write a single line of code, we must define the objectives and scope of the simulation. What specific question are we trying to answer? (e.g.&nbsp;if we add a new machine, will that bring the total waiting time to under 5 seconds?). What is inside the model, and what is outside? (e.g.&nbsp;do we need to model that materials need some time for disposal, or is this done instantly?).</p></li>
<li><p><strong>Data collection:</strong> This is typically the most time-consuming and difficult phase, where the goal is to gather real-world data to drive the model. This involves e.g.&nbsp;stopwatch studies, analyzing historical logs, and interviewing subject matter experts.</p></li>
<li><p><strong>Model translation</strong> This is the phase where the conceptual model is translated into a computer representation (the “coding” phase). This involves defining the entities, resources, and event logic within the chosen simulation software (e.g., SimPy, Arena, AnyLogic, or C++).</p></li>
<li><p><strong>Verification and validation:</strong> This is the quality control phase. Verification answers the question whether the code does what is intended to do. Comparing the model against Queuing Theory formulas is a primary method of verification. On the other hand, validation is concerned with accuracy, i.e.&nbsp;does the model behave like the real system?</p></li>
<li><p><strong>Experimentation and analysis:</strong> Once the model is valid, it becomes a virtual laboratory. We run scenarios (e.g., “Increase arrival rate by 20%”) and analyze the resulting output statistics to make specific recommendations.</p></li>
</ol>
<p><strong>The Markovian Assumption</strong></p>
<p>In <a href="#sec-queuing-theory" class="quarto-xref"><span>Section 4.2</span></a>, we relied heavily on the Exponential Distribution (Markovian) because it makes the mathematics solvable. However, in a simulation study, we are not bound by analytical convenience. Instead, we should and must use distributions that closer match reality.</p>
<p>Specifically, while arrivals do mostly follow a Poisson process (exponential interarrivals), scheduled arrivals do not. Regarding service times, humans are rarely exponential. A highly skilled worker might be consistent with low variance (Normal distribution), while machine repair times often follow a Weibull or Lognormal distribution. In this case, the main recommendation is to fit historical data to a probability curve. If we simply guess the distribution (e.g., assuming a machine always takes exactly 5 minutes when it actually varies between 2 and 12), the simulation results will underestimate the congestion caused by variance.</p>
</section>
<section id="analyzing-the-output" class="level3" data-number="4.3.4">
<h3 data-number="4.3.4" class="anchored" data-anchor-id="analyzing-the-output"><span class="header-section-number">4.3.4</span> Analyzing the Output</h3>
<p>Analyzing the output of a simulation is fundamentally different from reading a single number. Because DES is driven by random numbers, the output is also a random variable. Therfore, we need to express the results in the language of statistics and probability theory. Specifically, we need to use <strong>confidence intervals</strong>. E.g., instead of saying “The wait time is 10 minutes”, the simulation result should read something like: “We are 95% confident that the true average wait time lies between 9.2 and 10.8 minutes.” This requires running multiple replications (iterations) of the model to generate a statistically significant sample size, and using standard confidence interval tools to calculate the intervals.</p>
<p>It is also important to define a <strong>Warm-Up Period</strong>. In a steady-state simulation, the model usually starts “empty and idle.” This creates of course an initial bias. If we simulate a busy factory but start with zero parts in the system, the first few simulated hours will show misleadingly low queue times while the factory fills up. To correct this, the Warm-up Period (or transient period) is used to run the simulation for a specific time (e.g., 24 hours) to let the queues build up, delete the statistics from this period, and only collect data once the system reaches a stable state.</p>
</section>
</section>
<section id="comparative-study" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="comparative-study"><span class="header-section-number">4.4</span> Comparative Study</h2>
<p>To consolidate our understanding, we will now perform a comparative study. We will define a simple queuing system, solve it using the mathematical formulas derived in <a href="#sec-queuing-theory" class="quarto-xref"><span>Section 4.2</span></a>, and then build a Discrete Event Simulation (DES) in Python to solve it numerically.</p>
<p>Consider a small 24-hour IT Help Desk with a single technician. Support tickets arrive randomly following a Poisson process with a mean rate of 5 tickets per hour (<span class="math inline">\(\lambda=5\)</span>). The technician resolves tickets with service times that are exponentially distributed with a mean rate of <span class="math inline">\(\mu=6\)</span> tickets per hour. The queuing discipline is FIFO. Under these conditions, the system can be well described by a <span class="math inline">\(M/M/1\)</span> queuing model.</p>
<p>Our goal is to determine the average waiting time in the queue (<span class="math inline">\(W_q\)</span>) and the average number of tickets in the system (<span class="math inline">\(L\)</span>). Using the formulas derived in <a href="#sec-queuing-theory" class="quarto-xref"><span>Section 4.2</span></a>, we get:</p>
<p><span class="math display">\[
\rho=\frac{5}{6}=0.8333\dots
\]</span></p>
<p>So the technician is busy on average 83.3% of the time.</p>
<p><span class="math display">\[
\begin{aligned}
L &amp;= \frac{\rho}{1-\rho}=\frac{0.8333}{1-0.8333}=5 \\
W_q &amp;= \frac{\lambda}{\mu(\mu-\lambda)}=\frac{5}{6(6-5)}=\frac{5}{6}
\end{aligned}
\]</span></p>
<p>The average number of tickets in the system is 5, and the average waiting time is <span class="math inline">\(5/6\)</span> hours or 50 minutes. Let’s now build an equivalent DES system to replicate these results computationally. We start by defining the system parameters and some helpers:</p>
<div id="eedff2e2" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq  </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Configuration ---</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>RANDOM_SEED <span class="op">=</span> <span class="dv">42</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>TOTAL_TIME <span class="op">=</span> <span class="fl">20000.0</span>  <span class="co"># minutes</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>ARRIVAL_RATE <span class="op">=</span> <span class="fl">5.0</span> <span class="op">/</span> <span class="fl">60.0</span>  <span class="co"># lambda (customers per minute)</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>SERVICE_RATE <span class="op">=</span> <span class="fl">6.0</span> <span class="op">/</span> <span class="fl">60.0</span>  <span class="co"># mu (customers per minute)</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>WARMUP_TIME <span class="op">=</span> <span class="fl">100.0</span>   <span class="co"># Time to discard (Transient State)</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>clock <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>queue <span class="op">=</span> []  <span class="co"># Stores arrival times of waiting customers</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>server_busy <span class="op">=</span> <span class="va">False</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>fel <span class="op">=</span> []  <span class="co"># Future Event List</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>total_wait_time <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>total_customers_served <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>area_q_t <span class="op">=</span> <span class="fl">0.0</span>  <span class="co"># Area under Queue Length curve (for calculating Lq)</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>last_event_time <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>warmup_cleared <span class="op">=</span> <span class="va">False</span> <span class="co"># Flag to track if we have reset the stats</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> schedule_event(time, event_type):</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Adds an event to the FEL, sorted by time."""</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    heapq.heappush(fel, (time, event_type))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>The main simulation loop can be implemented as follows:</p>
<div id="62e009e2" class="cell" data-execution_count="2">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run_simulation():</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> clock, server_busy, total_customers_served, area_q_t, last_event_time, warmup_cleared</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    random.seed(RANDOM_SEED)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    interarrival <span class="op">=</span> random.expovariate(ARRIVAL_RATE)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    schedule_event(clock <span class="op">+</span> interarrival, <span class="st">'ARRIVAL'</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> clock <span class="op">&lt;</span> TOTAL_TIME <span class="kw">and</span> fel:</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        event_time, event_type <span class="op">=</span> heapq.heappop(fel)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        time_delta <span class="op">=</span> event_time <span class="op">-</span> last_event_time</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        queue_len <span class="op">=</span> <span class="bu">len</span>(queue)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> server_busy:</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>            queue_len <span class="op">+=</span> <span class="dv">1</span> <span class="co"># System Length = Queue + Service</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        area_q_t <span class="op">+=</span> queue_len <span class="op">*</span> time_delta</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        clock <span class="op">=</span> event_time</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        last_event_time <span class="op">=</span> clock</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> warmup_cleared <span class="kw">and</span> clock <span class="op">&gt;</span> WARMUP_TIME:</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>            area_q_t <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>            total_customers_served <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>            warmup_cleared <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> event_type <span class="op">==</span> <span class="st">'ARRIVAL'</span>:</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>            next_arrival <span class="op">=</span> clock <span class="op">+</span> random.expovariate(ARRIVAL_RATE)</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>            schedule_event(next_arrival, <span class="st">'ARRIVAL'</span>)</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> server_busy:</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>                server_busy <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>                service_time <span class="op">=</span> random.expovariate(SERVICE_RATE)</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>                schedule_event(clock <span class="op">+</span> service_time, <span class="st">'DEPARTURE'</span>)</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>                queue.append(clock)</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> event_type <span class="op">==</span> <span class="st">'DEPARTURE'</span>:</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> warmup_cleared:</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>                total_customers_served <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(queue) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>                _ <span class="op">=</span> queue.pop(<span class="dv">0</span>) <span class="co"># Entity enters service</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>                service_time <span class="op">=</span> random.expovariate(SERVICE_RATE)</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>                schedule_event(clock <span class="op">+</span> service_time, <span class="st">'DEPARTURE'</span>)</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>                server_busy <span class="op">=</span> <span class="va">False</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>    collection_duration <span class="op">=</span> clock <span class="op">-</span> WARMUP_TIME</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>    L_sim <span class="op">=</span> area_q_t <span class="op">/</span> collection_duration</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    W_sim <span class="op">=</span> L_sim <span class="op">/</span> ARRIVAL_RATE</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    Wq_sim <span class="op">=</span> W_sim <span class="op">-</span> (<span class="dv">1</span> <span class="op">/</span> SERVICE_RATE)</span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"--- Simulation Results (Steady State Only) ---"</span>)</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total Time: </span><span class="sc">{</span>TOTAL_TIME<span class="sc">}</span><span class="ss"> | Warm-up: </span><span class="sc">{</span>WARMUP_TIME<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Valid Data Duration: </span><span class="sc">{</span>collection_duration<span class="sc">:.1f}</span><span class="ss"> min"</span>)</span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total Customers Served (in valid period): </span><span class="sc">{</span>total_customers_served<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"-"</span> <span class="op">*</span> <span class="dv">30</span>)</span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Simulated L (Avg in System): </span><span class="sc">{</span>L_sim<span class="sc">:.4f}</span><span class="ss"> tickets"</span>)</span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Simulated Wq (Avg Wait in Queue): </span><span class="sc">{</span>Wq_sim<span class="sc">:.4f}</span><span class="ss"> min"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>The FEL is implemented using the <code>fel</code> variable. We start by scheduling the first arrival and entering the main loop. We then extract the first element from the FEL. If the server happens to be busy, we queue the element and schedule the next arrival. Otherwise, we serve the element and schedule its departure from the system. The departure event schedules the next departure if there are still elements waiting in the queue, otherwise it sets the state variable <code>server_busy</code> again to <code>False</code>. Note that we are calculating <code>L_sim</code> (the simulated length of the system) by just calculating the area under the curve that describes the current length of the system and dividing by the total time to get the average. The other quantities are given by Little’s Law.</p>
<p>We now run the simulation</p>
<div id="23f9d9c1" class="cell" data-execution_count="3">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>run_simulation()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>--- Simulation Results (Steady State Only) ---
Total Time: 20000.0 | Warm-up: 100.0
Valid Data Duration: 19927.2 min
Total Customers Served (in valid period): 1666
------------------------------
Simulated L (Avg in System): 5.5395 tickets
Simulated Wq (Avg Wait in Queue): 56.4742 min</code></pre>
</div>
</div>
<p>As can be seen, the result are close to the theoretical 5 tickets and 50 minutes. The more steps we simulate, the closer will the system get to the true analytical results. Note that we are discarding the events that happened before <code>WARMUP_TIME</code> so that the system has enough time to leave the initial, empty state and reach a steady state.</p>
<p>However, what is then the point of DES, if we can calculate everything analytically? The reason is that, in practice, very often we can’t. For instance, imagine that additionally we have the rule that the technician takes a 10-minute break every 2 hours, but only if no high-priority tickets are waiting. Queuing Theory can’t handle this problem, so we need to resort to DES instead. In the simulation code, it would be enough to add some additional logic to model this case accurately.</p>
</section>
<section id="summary-1" class="level2" data-number="4.5">
<h2 data-number="4.5" class="anchored" data-anchor-id="summary-1"><span class="header-section-number">4.5</span> Summary</h2>
<p>In this chapter, we have explored the complementary relationship between the mathematical elegance of Queuing Theory and the computational power of Discrete Event Simulation (DES). We began by establishing the fundamental vocabulary of systems engineering: entities, resources, and queues. We learned that while Queuing Theory provides exact, closed-form solutions for performance metrics like <span class="math inline">\(L\)</span> and <span class="math inline">\(W_q\)</span>, it is bounded by the assumptions. When a system involves complex routing, time-varying arrival rates, or resource dependencies, analytical formulas become intractable. This is where Discrete Event Simulation takes over. By modeling a system not as a continuous flow but as a sequence of distinct events managed by a Future Event List (FEL) and a Next-Event Time Advance clock, we can reconstruct complex reality inside a computer. However, we also demonstrated that simulation is not a replacement for theory, but an extension of it. Through the <span class="math inline">\(M/M/1\)</span> Case Study, we showed that Queuing Theory serves a critical role as a verification tool. By simplifying a simulation model to match standard theoretical assumptions, we can mathematically validate the underlying code before re-introducing real-world complexities.</p>
</section>
<section id="exercises" class="level2" data-number="4.6">
<h2 data-number="4.6" class="anchored" data-anchor-id="exercises"><span class="header-section-number">4.6</span> Exercises</h2>
<ol type="1">
<li><p>Consider a cloud computing server that processes requests (jobs). The arrivals follow a Poisson distribution with a mean rate of <span class="math inline">\(\lambda\)</span> jobs per minute, and the service times are exponentially distributed with a mean rate of <span class="math inline">\(\mu\)</span> jobs per minute. Assume <span class="math inline">\(\lambda=4\)</span> jobs/min and <span class="math inline">\(\mu=5\)</span> jobs/min. Calculate the utilization factor <span class="math inline">\(\rho\)</span>, the average waiting time in the queue <span class="math inline">\(W_q\)</span> and the average number of jobs in the system <span class="math inline">\(L\)</span>.</p></li>
<li><p>Due to a marketing campaign, the arrival rate increases slightly to <span class="math inline">\(\lambda=4.8\)</span> jobs/min. The server speeds remains at <span class="math inline">\(\mu=5\)</span>. Calculate the new average waiting time in the queue <span class="math inline">\(W_q\)</span>. By what percentage did the waiting time increase? Compare it to the traffic increase and explain the difference.</p></li>
<li><p>Modify the provided Python code to simulate a <span class="math inline">\(M/M/3\)</span> model instead (i.e.&nbsp;with 3 parallel servers). What needs to be changed in the code? Compare the simulated Average Waiting Time <span class="math inline">\(W_q\)</span> in the case <span class="math inline">\(\mu=5\)</span> with 3 servers and <span class="math inline">\(M/M/1\)</span> with <span class="math inline">\(\mu=15\)</span>. Are they the same? Why?</p></li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./monte_carlo.html" class="pagination-link" aria-label="Monte Carlo">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Monte Carlo</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./optimization_basics.html" class="pagination-link" aria-label="Optimization basics">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Optimization basics</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>