<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>1&nbsp; Introduction – Simulation and Optimization: A Model-Driven Approach</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./simulation_basics.html" rel="next">
<link href="./preface.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-e48e5d47e6899f26dc5bcf87b02f963a.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script>
MathJax = {
  tex: {
    tags: 'ams'
  }
};
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./intro.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Simulation and Optimization: A Model-Driven Approach</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">PART I: SIMULATION</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./simulation_basics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Simulation basics</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./monte_carlo.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Monte Carlo</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./discrete_event.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Discrete events and Queuing Theory</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">PART II: OPTIMIZATION</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./optimization_basics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Optimization basics</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./exact_methods.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Exact methods</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./metaheuristics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Metaheuristics</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./optimization_in_ml.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Optimization and Simulation in Machine Learning</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./summary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Summary</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#example-1-simulating-supermarket-dynamics" id="toc-example-1-simulating-supermarket-dynamics" class="nav-link active" data-scroll-target="#example-1-simulating-supermarket-dynamics"><span class="header-section-number">1.1</span> Example 1: Simulating supermarket dynamics</a></li>
  <li><a href="#example-2-the-traveling-salesman" id="toc-example-2-the-traveling-salesman" class="nav-link" data-scroll-target="#example-2-the-traveling-salesman"><span class="header-section-number">1.2</span> Example 2: The traveling salesman</a></li>
  <li><a href="#structure-of-the-book" id="toc-structure-of-the-book" class="nav-link" data-scroll-target="#structure-of-the-book"><span class="header-section-number">1.3</span> Structure of the book</a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="header-section-number">1.4</span> Exercises</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-introduction" class="quarto-section-identifier"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Simulation and optimization approaches are present in our everyday lives, albeit most of the time operating in a background plane. For example, when navigating with a GPS, the system simulates different routes and optimizes for the shortest or fastest path. Similarly, supply chains use optimization algorithms to minimize costs and maximize efficiency, while simulations help predict demand and manage inventory. These techniques are fundamental tools in decision-making processes across various industries, from transportation and logistics to finance and healthcare.</p>
<p>But what do simulation and optimization approaches have in common, apart from being complementary tools? The answer lies in the concept of a <em>model</em>. In the context of machine learning, we normally refer to a model as a mathematical or computational representation that captures the relationships between input data and output predictions. In simulation and optimization, a model similarly serves as an abstraction of a real-world system or process, allowing us to analyze, predict, and improve its behavior through experimentation and algorithmic techniques.</p>
<p>In the following, we will delve deeper into the concept of a model and how models are used in simulation and optimization contexts using some practical examples.</p>
<section id="example-1-simulating-supermarket-dynamics" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="example-1-simulating-supermarket-dynamics"><span class="header-section-number">1.1</span> Example 1: Simulating supermarket dynamics</h2>
<p>Imagine you are in your favourite grocery store waiting at the checkout queue. For simplicity, let’s assume there is only one open counter. When you arrive at the queue, there might be other customers already waiting, while the first customer at the queue is currently being served. Shortly after you, a new customer arrives, taking the next free spot right behind you. And then another customer arrives, and another one, and another one…</p>
<p>Let’s try to break down how this system behaves and what are the most important interactions between the parts of the system. In general, we will distinguish between <em>components</em>, <em>states</em>, <em>events</em>, <em>inputs</em> and <em>metrics</em>.</p>
<ul>
<li><strong>Components:</strong> These are the entities that interact with each other. In our example, we have customers, cashiers and the queue itself.</li>
<li><strong>States:</strong> The configurations of the system that represent valid combinations of specific properties of the components at a given moment of time. For instance, at each time the queue has a specific length: zero if it’s empty, one customer, two customers, etc. Additionally, the cashier can be busy or idle. We can also count the number of customers currently present in the supermarket which have not yet arrive at the checkout queue.</li>
<li><strong>Events:</strong> The interactions themselves, like a new customer arriving at the queue, checkout start or checkout completion.</li>
<li><strong>Inputs:</strong> Whatever information is fed into the system, e.g.&nbsp;arrival times, service times, etc. These inputs can contain statistical assumptions, like the distribution of arrival times.</li>
<li><strong>Metrics:</strong> How we evaluate the system as a whole in a given time step. For instance, what is the average waiting time? How much time are the cashiers busy? How is the queue length distributed?</li>
</ul>
<p>The system could be represented by the following Python code as a minimal variant.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq, random</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># event = (time, type, customer_id)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>event_list <span class="op">=</span> []</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>heapq.heappush(event_list, (first_arrival_time, <span class="st">'arrival'</span>, <span class="dv">1</span>))</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> event_list <span class="kw">and</span> time <span class="op">&lt;</span> sim_end:</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    time, ev_type, cid <span class="op">=</span> heapq.heappop(event_list)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ev_type <span class="op">==</span> <span class="st">'arrival'</span>:</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> any_cashier_free():</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            start_checkout(cid, time)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            heapq.heappush(event_list, (time <span class="op">+</span> service_time(cid), </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>                <span class="st">'departure'</span>, cid))</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>            enqueue(cid, time)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        heapq.heappush(event_list, (time <span class="op">+</span> next_interarrival(), </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>            <span class="st">'arrival'</span>, next_id()))</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> ev_type <span class="op">==</span> <span class="st">'departure'</span>:</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        finish_service(cid, time)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> queue_not_empty():</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>            next_cid <span class="op">=</span> dequeue()</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>            start_service(next_cid, time)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>            heapq.heappush(event_list, (time <span class="op">+</span> service_time(next_cid), </span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>                <span class="st">'departure'</span>, next_cid))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This code assumes that customers arrive at regular subsequent intervals after each arrival event. The parameter <code>sim_end</code> defines how long (how many steps) we want to simulate in this case. The function <code>service_time</code> returns the time the cashier needs for checking out customer <code>cid</code>. The next customer will arrive after a time given by the function <code>next_interarrival</code>, which can implement different stochastic behaviours.</p>
<p>We can represent this system graphically as shown in the following illustration:</p>
<div id="fig-supermarket-dynamics" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-supermarket-dynamics-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/fig_intro_1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-supermarket-dynamics-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1.1: An illustration of the supermarket dynamics.
</figcaption>
</figure>
</div>
<p>In this figure, customers are denoted by <span class="math inline">\(r_i\)</span>, the amount of cashiers is <span class="math inline">\(c\)</span> and the total number of customers in the supermarket at time <span class="math inline">\(t\)</span> is denoted by <span class="math inline">\(N(t)\)</span>.</p>
<p>Now let’s try to refine the dynamics of this system. We will now write some equations to describe the system’ dynamics according to the <strong>infinite waiting room</strong> <span class="math inline">\(M/M/c\)</span> model. Let’s make the following assumptions:</p>
<ul>
<li>Arrivals follow a Poisson distribution with mean <span class="math inline">\(\lambda\)</span> (arrivals per second), which for this case will be assumed to be stationary.</li>
<li>The service times are assumed to be exponentially distributed with mean <span class="math inline">\(1/\mu\)</span>.</li>
</ul>
<p>What would be now the <em>traffic intensity per cashier</em>? That is, what is the mean customer flow that each cashier experiences from their own point of view? Let’s call this number <span class="math inline">\(\rho\)</span> and calculate it as follows:</p>
<p><span id="eq-1-1"><span class="math display">\[
\rho=\frac{\lambda}{c\mu}
\tag{1.1}\]</span></span></p>
<p>In words, if customers arrive at a rate of <span class="math inline">\(\lambda=10\)</span> customers/s and each cashier serves 2 customers/s (yes, it’s a fast supermarket). With 5 cashiers, that means that <span class="math inline">\(\rho=10/5\times 2=1\)</span>. This means that each cashier has quite a lot to do right now.</p>
<p>We are now interested in the probabilities of the states in this systems. In this case, we define a system by the number of customers currently present in the supermarket. So we can have <span class="math inline">\(N=1\)</span> if there is currently 1 customer present, or any other number of customers (we assume the supermarket is so large, we can accomodate any number of them). Let’s denote these probabilities by <span class="math inline">\(p_n=\operatorname{Pr}\{N=n\}\)</span>. We have:</p>
<p><span id="eq-1-2"><span class="math display">\[
p_n=\lim_{t\rightarrow\infty}\int_{0}^t \mathbb{1}_{\{N(s)=n\}} ds
\tag{1.2}\]</span></span></p>
<p>Intuitively, <span class="math inline">\(p_n\)</span> represents the fraction of time where the supermarket has exactly <span class="math inline">\(n\)</span> customers. As mentioned earlier, we will assume that arrivals do not depend of the current state <span class="math inline">\(n\)</span>, so we write <span class="math inline">\(\lambda_n=\lambda\)</span> for all <span class="math inline">\(n\ge 0\)</span>. However, note that the completion rates <span class="math inline">\(\mu_n\)</span> do <em>indeed</em> depend of the current state. To see this, imagine that there is only one customer in the supermarket (<span class="math inline">\(n=1\)</span>). The completion rate is then <span class="math inline">\(\mu_1=\mu\)</span> since the only one cashier is needed to perform checkout. However, if there are <span class="math inline">\(n=2\)</span> customers in the supermarket, two cashiers can serve those two customers in parallel, increasing the completion rate to <span class="math inline">\(\mu_2 = 2\mu\)</span>. The same reasoning applies until <span class="math inline">\(n=c\)</span>, the total number of cashiers. In this case, <span class="math inline">\(\mu_c=c\mu\)</span> and the next customer will have to wait in the queue. So we have:</p>
<p><span id="eq-1-3"><span class="math display">\[
\begin{aligned}
\lambda_n &amp; =\lambda \text{ for all } n\ge 0 \\
\mu_n &amp; =\min(n,c)\mu
\end{aligned}
\tag{1.3}\]</span></span></p>
<p>Now we are going to state our <strong>main modeling assumption</strong>. Consider how we transition <em>between states</em>. Specifically, we transition from state <span class="math inline">\(n\)</span> to state <span class="math inline">\(n+1\)</span> when a new customer enters the supermarket, and there were already <span class="math inline">\(n\)</span> customers in it. Similarly, we transition from state <span class="math inline">\(n\)</span> to state <span class="math inline">\(n-1\)</span> when a customer leaves the supermarket (in this case, all customers are served by the cashiers, so there is no way you leave the supermarket without paying first). Remember that the rate of customers arriving at the supermarket is always <span class="math inline">\(\lambda\)</span>, and the rate of customers being served (i.e.&nbsp;leaving) when at state <span class="math inline">\(n\)</span> is <span class="math inline">\(\mu_n\)</span>. In general, for each state we can define an <em>incoming</em> and an <em>outgoing flow</em>. This quantifies the transitions in resp. out of a given state.</p>
<div id="fig-transition-neighboring" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-transition-neighboring-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/fig_intro_2.png" class="img-fluid figure-img" style="width:70.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-transition-neighboring-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1.2: Transition dynamics between neighboring states
</figcaption>
</figure>
</div>
<p>As can be seen in the previous figure, transitions flow away from state <span class="math inline">\(n\)</span> in two ways: first, to state <span class="math inline">\(n-1\)</span> when a customer is served with a rate <span class="math inline">\(\mu_n p_n\)</span> and to state <span class="math inline">\(n+1\)</span> when a new customer arrives with a rate <span class="math inline">\(\lambda p_n\)</span>. Similarly, one can transition from the other states to state <span class="math inline">\(n\)</span> either by having a customer served in state <span class="math inline">\(n+1\)</span> with a rate <span class="math inline">\(\mu_{n+1}p_{n+1}\)</span> or when being in state <span class="math inline">\(n-1\)</span> and a new customer arrives with a rate <span class="math inline">\(\lambda p_{n-1}\)</span>. Our modeling assumption now is that, for each state <span class="math inline">\(n\)</span>, the flow outwards balances out with the flow inwards (global balance):</p>
<p><span id="eq-1-4"><span class="math display">\[
\lambda p_{n-1} + \mu_{n+1}p_{n+1} = \lambda p_n + \mu_n p_n\text{,   for }n\ge 1
\tag{1.4}\]</span></span></p>
<p>We can also write that, in the long term, the rate of transitions from <span class="math inline">\(n\)</span> to <span class="math inline">\(n+1\)</span> equals the transitions from <span class="math inline">\(n+1\)</span> to <span class="math inline">\(n\)</span>, which results in the more simple form (local balance)</p>
<p><span id="eq-1-5"><span class="math display">\[
\lambda p_n = \mu_{n+1}p_{n+1} \text{,   for }n\ge 1
\tag{1.5}\]</span></span></p>
<p>This form follows from the global balance condition when only neighboring states are connected. Now, using this short form, we can provide closed-form expressions for different probabilities, using the following recursion (which directly follows from the above)</p>
<p><span id="eq-1-6"><span class="math display">\[
p_{n+1}=\frac{\lambda}{\mu_{n+1}}p_n
\tag{1.6}\]</span></span></p>
<p>For instance, one can calculate that the probability of a customer having to wait (because all cashiers are busy at the moment) is</p>
<p><span id="eq-1-7"><span class="math display">\[
P_W=p_0\frac{(\lambda/\mu)^c}{c!}\frac{1}{1-\rho}
\tag{1.7}\]</span></span></p>
<p>This is also called the <em>Erlang-C</em> probability and we will delve deeper into the details in the coming chapters.</p>
<p>We can now write computer code that performs a step-by-step simulation of the system (i.e.&nbsp;in discrete time steps). This is specially useful if we are in a situation where there is no closed-form analytical solution, or the analytical solution is too complex to calculate. For instance, we can run the above simulator for a large number of steps (say <span class="math inline">\(T=10^6\)</span>) and then calculate specific metrics like:</p>
<ul>
<li>Mean queue length.</li>
<li>Mean waiting time.</li>
<li>Mean time in the system.</li>
<li>Total fraction of time that the cashiers were busy.</li>
<li>Overall utilization.</li>
</ul>
<p>We will see examples of such simulators in the first part of the book.</p>
</section>
<section id="example-2-the-traveling-salesman" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="example-2-the-traveling-salesman"><span class="header-section-number">1.2</span> Example 2: The traveling salesman</h2>
<p>Let’s not turn our attention to the other type of problems which are central to this book: <em>optimization problems</em>. Imagine you are a sales representative for a vaccum cleaner manufacturer. Your task is to visit potential customers in cities across your area and, at the end of the day, return to where you started your journey. As an environmental conscious employer and in order to save transport costs, your company introduces the restriction that each customer in the route has to be visited <em>exactly once</em>. So you need to think carefully before getting into your car and starting your route.</p>
<div id="fig-tsp-1" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-tsp-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/fig_intro_3.png" class="img-fluid figure-img" style="width:70.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-tsp-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1.3: The traveling salesman has to find a good and practical solution
</figcaption>
</figure>
</div>
<p>Now, the traveling salesman needs to consider two things:</p>
<ul>
<li>A method for <em>constructing valid</em> tours that start and end in the same location.</li>
<li>A method for <em>evaluating</em> those tours so that we can quantitatively decide if a tour is better than another one.</li>
</ul>
<p>Let’s address each of these considerations in detail. Assume that <span class="math inline">\(N=\{1,2,\dots,n\}\)</span> is our set of possible locations. Let’s define the following variables:</p>
<p><span id="eq-1-8"><span class="math display">\[
\begin{aligned}
x_{ij}=
\begin{cases}
1 &amp; \text{if the tour goes directly to location }i \text{ to location }j \\
0 &amp; \text{otherwise}
\end{cases}
\end{aligned}
\tag{1.8}\]</span></span></p>
<p>where <span class="math inline">\(i,j\in N\)</span>. We call <span class="math inline">\(x_{ij}\)</span> our <em>decision variables</em>. So if the traveling salesman specifies the value of each <span class="math inline">\(x_{ij}\)</span>, we have a candidate route to consider. However, not every assignment of the <span class="math inline">\(x_{ij}\)</span> variables to <span class="math inline">\(\{0,1\}\)</span> will make sense for the traveling salesman. For instance, imagine that we have in one assignment both <span class="math inline">\(x_{23}=1\)</span> and <span class="math inline">\(x_{43}=1\)</span>. That would mean that location 3 is visited twice, once from location 2 and another time from location 4. That violates the requirement that each location is visited exactly once.</p>
<p>To model this situation, we need to introduce <em>constraints</em>. In optimization problems, constraints take usually the form of equalities or inequalities as functions of the decision variables. In our case, the requirement that each location is visited only once can be expressed by the following (linear) equalities:</p>
<p><span id="eq-1-9"><span class="math display">\[
\begin{aligned}
\sum_{j=1}^n x_{ij} &amp; = 1\text{ for all }i\in N \\
\sum_{i=1}^n x_{ij} &amp; = 1\text{ for all }j\in N
\end{aligned}
\tag{1.9}\]</span></span></p>
<p>The first equality means that, fixed a location <span class="math inline">\(i\)</span>, the sum of all <em>outgoing</em> edges is exactly one. Conversely, the second states that for a fixed location <span class="math inline">\(j\)</span>, the sum of all <em>incoming</em> edges is also exactly one. This ensures that each location is visited exactly once.</p>
<p>We need another technical condition to guarantee that the tour is a single one and not composed of multiple sub-tours. There should be no subset <span class="math inline">\(S \subset N\)</span> such that is self contained, the number of visited cities equals exactly its size. Mathematically:</p>
<p><span id="eq-1-10"><span class="math display">\[
\sum_{i\in N}\sum_{j\in N} x_{ij} \le |S|-1\text{ for all subsets }S\subset N
\tag{1.10}\]</span></span></p>
<p>To sum up, we now have modeled how valid tours should look like. If we find a tour <span class="math inline">\(T=\{x_{ij}\}\)</span> that satisfies the constraints outlined before, we can be sure it is a valid tour.</p>
<p>But surely there are some tours that are better than others? This is where the second issue becomes important: we need an evaluation method to distinguish between good and bad solutions. In the optimization literature, we normally talk about <strong>objective functions</strong>. In our case, the traveling salesman would like the total distance to be <em>minimized</em>, meaning the sum of all distances between locations of the tour. Assume that <span class="math inline">\(c_{ij}&gt;0\)</span> is the distance between location <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> (for consistency assume <span class="math inline">\(c_{ii}=0\)</span>). Now we want to minimize the total distance traveled. For this we write:</p>
<p><span id="eq-total-cost"><span class="math display">\[
\min \sum_{i\in N}\sum_{j\in N} c_{ij}x_{ij}
\tag{1.11}\]</span></span></p>
<p>That is, if the traveling salesman visits location <span class="math inline">\(j\)</span> from <span class="math inline">\(i\)</span>, then <span class="math inline">\(x_{ij}=1\)</span> and this activates the travel cost <span class="math inline">\(c_{ij}\)</span> in the sum. Otherwise, <span class="math inline">\(x_{ij}=0\)</span> and the cost does not count to the total sum, since that path is not traversed in the tour. Putting it all together, we have:</p>
<p><span id="eq-opt-model"><span class="math display">\[
\begin{aligned}
T^* &amp; =\operatorname{argmin} \sum_{i\in N}\sum_{j\in N} c_{ij}x_{ij} \\
\text{s.t. } &amp; \sum_{j=1}^n x_{ij} = 1\text{ for all }i\in N \\
&amp; \sum_{i=1}^n x_{ij} = 1\text{ for all }j\in N \\
&amp; \sum_{i\in N}\sum_{j\in N} x_{ij} \le |S|-1\text{ for all subsets }S\subset N \\
&amp; x_{ij} \in \{0,1\}
\end{aligned}
\tag{1.12}\]</span></span></p>
<p>We call this set of expressions our <em>optimization model</em>. This will be the mathematical underpinning for all the methods and algorithms that we will use to find a solution to this problem. In the first line, we state our goal: to obtain a tour <span class="math inline">\(T^*\)</span> that is optimal in the sense of minimizing the total cost (the expression <span class="math inline">\(\operatorname{argmin}\)</span> means “the argument that minimizes”, so find the <span class="math inline">\(x_{ij}\)</span> that minimize the total cost function). The subsequent lines state the <em>constraints</em> that we listed before. In the last line we specify the <em>domain</em> of the decision variables, i.e.&nbsp;what are the possible values these variables can take.</p>
<p>We will see that, depending on the form of the optimization model we will be able to choose from a toolbox of algorithms capable to solve the problem at hand, either exactly (<em>exact methods</em>) or approximately (<em>heuristic methods</em>).</p>
</section>
<section id="structure-of-the-book" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="structure-of-the-book"><span class="header-section-number">1.3</span> Structure of the book</h2>
<p>In this first chapter, we have introduced the concept of a <em>model</em> and have applied it successfully to a simulation and an optimization problem. The rest of the book is structured in two parts: Part I will be dedicated to simulation approaches, including the <span class="math inline">\(M/M/c\)</span> model we have seen in this chapter in <a href="simulation_basics.html" class="quarto-xref"><span>Chapter 2</span></a>. Monte Carlo methods are the main topic of <a href="monte_carlo.html" class="quarto-xref"><span>Chapter 3</span></a>. After that, <a href="discrete_event.html" class="quarto-xref"><span>Chapter 4</span></a> focuses on the handling of discrete events, while <span class="quarto-unresolved-ref">?sec-agent-based</span> concludes with considerations about agent-based modeling and simulation.</p>
<p>Part II is dedicated to optimization problems. In <a href="optimization_basics.html" class="quarto-xref"><span>Chapter 5</span></a> we introduce the mathematical basics of optimization. <a href="exact_methods.html" class="quarto-xref"><span>Chapter 6</span></a> is dedicated to exact optimization methods like the simplex method for linear programming. Approximate methods for complex optimization problems like metaheuristics and evolutionary algorithms are presented in <a href="metaheuristics.html" class="quarto-xref"><span>Chapter 7</span></a>. Finally, we review the importance of optimization methods for machine learning in <a href="optimization_in_ml.html" class="quarto-xref"><span>Chapter 8</span></a>.</p>
</section>
<section id="exercises" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="exercises"><span class="header-section-number">1.4</span> Exercises</h2>
<ol type="1">
<li>Prove that in the supermarket example the local balance condition follows from the global balance condition (Hint: use induction).</li>
<li>What happens to the optimization model in presented in <a href="#eq-opt-model" class="quarto-xref">Equations&nbsp;<span>1.12</span></a> if we remove <a href="#eq-1-10" class="quarto-xref">Equation&nbsp;<span>1.10</span></a>? Find an example of a tour that is valid according to the model but invalid for the traveling salesman.</li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./preface.html" class="pagination-link" aria-label="Preface">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Preface</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./simulation_basics.html" class="pagination-link" aria-label="Simulation basics">
        <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Simulation basics</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>